// src/features/proposals/proposals-logic/useProposalsStore.jsx
import { create } from "zustand";

// ================== CONFIG ==================
const ENV_BASE = import.meta?.env?.VITE_API_URL?.replace(/\/$/, "");
const API_BASE = ENV_BASE || "http://localhost:5295/api";
let PROPOSALS_URL = `${API_BASE}/Proposal`; // Primary URL
const FALLBACK_URL = `${API_BASE}/proposals`; // Fallback n·∫øu 404 (lowercase)

// ===== JWT helpers (KH√îNG ƒë·ªïi UI) =====
const getAccessToken = () => {
  // T√πy app c·ªßa b·∫°n l∆∞u token ·ªü ƒë√¢u: localStorage / sessionStorage
  const direct =
    localStorage.getItem("accessToken") ||
    sessionStorage.getItem("accessToken");
  if (direct) return direct;

  // Fallback: n·∫øu l∆∞u object 'auth' { accessToken: "..." }
  try {
    const auth = JSON.parse(
      localStorage.getItem("auth") || sessionStorage.getItem("auth") || "{}"
    );
    if (auth?.accessToken) return auth.accessToken;
  } catch {
    return null;
  }
  return null;
};

const authHeaders = () => {
  const token = getAccessToken();
  return token ? { Authorization: `Bearer ${token}` } : {};
};

// Helper parse response
const parseApiResponse = async (res) => {
  const text = await res.text();
  try {
    return JSON.parse(text);
  } catch {
    return { success: res.ok, message: text || res.statusText, data: null };
  }
};

// ================== STORE ==================
export const useProposalsStore = create((set, get) => ({
  // UI State
  isModalOpen: false,
  mode: "add",
  selectedProposal: null,
  openModal: (mode = "add", proposal = null) => {
    set({ isModalOpen: true, mode, selectedProposal: proposal });
  },
  closeModal: () => set({ isModalOpen: false }),

  // Data State
  proposals: [],
  finalProposals: [],
  selectedProposalId: null,
  searchTerm: "",
  counts: { "T·∫•t c·∫£": 0, "ƒê√£ duy·ªát": 0, "Ch·ªù duy·ªát": 0, "B·ªã t·ª´ ch·ªëi": 0 },
  isLoading: false,
  error: null,

  // ============ SETTERS ============
  setError: (err) => set({ error: err }),

  setSearchTerm: (term) => {
    const filtered = (get().proposals || []).filter((p) =>
      p.title.toLowerCase().includes((term || "").toLowerCase())
    );
    set({ searchTerm: term, finalProposals: filtered });
  },

  setSelectedProposalId: (id) => {
    const proposals = get().proposals || [];
    const selected = proposals.find((p) => String(p.id) === String(id)) || null;
    set({ selectedProposalId: id, selectedProposal: selected });
  },

  setMode: (mode) => set({ mode }),

  // ================== NORMALIZE ==================
  normalizeProposal: (p) => {
    const normalized = {
      id: String(p.projectId || p.id),
      title: p.title || "Kh√¥ng c√≥ ti√™u ƒë·ªÅ",
      summary: p.description || p.summary || "Ch∆∞a c√≥ m√¥ t·∫£",
      mentor:
        p.mentor?.fullName || p.lecturer?.fullName || "Ch∆∞a c√≥ gi·∫£ng vi√™n",
      members: Array.isArray(p.teamMembers)
        ? p.teamMembers.map(
            (m) => m.fullName || m.studentName || m.name || "Th√†nh vi√™n"
          )
        : [],
      registerDate: p.registrationDate
        ? new Date(p.registrationDate).toLocaleDateString("vi-VN")
        : "N/A",
      status:
        p.status === "Pending" || p.status === "0" || !p.status
          ? "Ch·ªù duy·ªát"
          : p.status === "Approved" || p.status === "1"
          ? "ƒê√£ duy·ªát"
          : p.status === "Rejected" || p.status === "2"
          ? "B·ªã t·ª´ ch·ªëi"
          : "Ch·ªù duy·ªát",
      goals: p.goals || ["Ch∆∞a c·∫≠p nh·∫≠t"],
      technologies: p.technologies || ["Ch∆∞a c·∫≠p nh·∫≠t"],
      pdfUrl: p.pdfUrl || p.filePath || p.pdfPath || "",
    };
    // console.log("Debug - Normalized proposal:", normalized);
    return normalized;
  },

  // ================== ADD PROPOSAL ==================
  addProposal: async (formData) => {
    try {
      const res = await fetch(`${PROPOSALS_URL}/upload`, {
        method: "POST",
        headers: {
          ...authHeaders(), // ‚úÖ ch·ªâ th√™m Authorization (ƒë·ª´ng set Content-Type cho FormData)
        },
        body: formData,
      });

      const payload = await parseApiResponse(res);
      if (!res.ok)
        throw new Error(
          payload?.message || res.statusText || "T·∫°o ƒë·ªÅ t√†i th·∫•t b·∫°i"
        );

      // console.log("Debug - Response khi t·∫°o ƒë·ªÅ t√†i:", payload);
      await get().fetchProposals();
      return true;
    } catch (err) {
      console.error("L·ªói khi t·∫°o ƒë·ªÅ t√†i:", err);
      alert(`T·∫°o ƒë·ªÅ t√†i th·∫•t b·∫°i: ${err.message}`);
      return false;
    }
  },

  // ================== FETCH ALL ==================
  fetchProposals: async (useFallback = false) => {
    // Th√™m param ƒë·ªÉ th·ª≠ fallback URL
    set({ isLoading: true, error: null });
    const urlToUse = useFallback ? FALLBACK_URL : PROPOSALS_URL;
    console.log(`üîÑ Fetching proposals from: ${urlToUse}`); // Debug log

    try {
      const res = await fetch(urlToUse, {
        method: "GET",
        headers: {
          Accept: "application/json",
          ...authHeaders(), // ‚úÖ c·∫ßn bearer token
        },
      });

      const payload = await parseApiResponse(res);
      console.log("üì° API Response status:", res.status, "Payload:", payload); // Debug

      if (!res.ok) {
        // Kh√¥ng throw n·ªØa, set error v√† th·ª≠ fallback n·∫øu primary fail
        const errorMsg =
          payload?.message || res.statusText || "L·ªói t·∫£i d·ªØ li·ªáu";
        set({ error: errorMsg, isLoading: false });

        if (res.status === 404 && !useFallback) {
          console.warn("‚ö†Ô∏è Primary URL 404, th·ª≠ fallback URL...");
          return get().fetchProposals(true); // Retry v·ªõi fallback
        }

        // Mock data n·∫øu v·∫´n fail (cho dev/test)
        if (res.status === 404) {
          console.warn("‚ö†Ô∏è API ch∆∞a s·∫µn s√†ng, d√πng mock data...");
          const mockData = [
            {
              id: "1",
              title: "ƒê·ªÅ t√†i m·∫´u 1: Ph√°t tri·ªÉn Web App",
              summary: "·ª®ng d·ª•ng qu·∫£n l√Ω d·ª± √°n v·ªõi React v√† ASP.NET",
              mentor: "TS. Nguy·ªÖn VƒÉn A",
              members: ["Sinh vi√™n B", "Sinh vi√™n C"],
              registerDate: "01/10/2025",
              status: "Ch·ªù duy·ªát",
              goals: ["Ho√†n th√†nh MVP", "T√≠ch h·ª£p API"],
              technologies: ["React", "ASP.NET Core"],
              pdfUrl: "/mock/proposal1.pdf",
            },
            {
              id: "2",
              title: "ƒê·ªÅ t√†i m·∫´u 2: AI Chatbot",
              summary: "X√¢y d·ª±ng chatbot h·ªó tr·ª£ h·ªçc t·∫≠p",
              mentor: "PGS.TS. Tr·∫ßn Th·ªã B",
              members: ["Sinh vi√™n D"],
              registerDate: "15/09/2025",
              status: "ƒê√£ duy·ªát",
              goals: ["Train model", "Deploy tr√™n cloud"],
              technologies: ["Python", "TensorFlow"],
              pdfUrl: "/mock/proposal2.pdf",
            },
            {
              id: "3",
              title: "ƒê·ªÅ t√†i m·∫´u 3: Mobile App Fitness",
              summary: "·ª®ng d·ª•ng theo d√µi s·ª©c kh·ªèe",
              mentor: "TS. L√™ VƒÉn C",
              members: ["Sinh vi√™n E", "Sinh vi√™n F"],
              registerDate: "20/08/2025",
              status: "B·ªã t·ª´ ch·ªëi",
              goals: ["UI/UX design"],
              technologies: ["Flutter", "Firebase"],
              pdfUrl: "",
            },
          ];
          const normalizedData = mockData.map(get().normalizeProposal);
          const newCounts = {
            "T·∫•t c·∫£": normalizedData.length,
            "ƒê√£ duy·ªát": normalizedData.filter((p) => p.status === "ƒê√£ duy·ªát")
              .length,
            "Ch·ªù duy·ªát": normalizedData.filter((p) => p.status === "Ch·ªù duy·ªát")
              .length,
            "B·ªã t·ª´ ch·ªëi": normalizedData.filter(
              (p) => p.status === "B·ªã t·ª´ ch·ªëi"
            ).length,
          };
          set({
            proposals: normalizedData,
            finalProposals: normalizedData,
            counts: newCounts,
            selectedProposalId: normalizedData[0]?.id || null,
            selectedProposal: normalizedData[0] || null,
            isLoading: false,
          });
          return; // D·ª´ng fetch, d√πng mock
        }

        return; // N·∫øu error kh√°c 404, d·ª´ng v√† ƒë·ªÉ UI handle
      }

      const rawData = payload?.data ?? payload;
      const normalizedData = (rawData || []).map(get().normalizeProposal);

      const newCounts = {
        "T·∫•t c·∫£": normalizedData.length,
        "ƒê√£ duy·ªát": normalizedData.filter((p) => p.status === "ƒê√£ duy·ªát")
          .length,
        "Ch·ªù duy·ªát": normalizedData.filter((p) => p.status === "Ch·ªù duy·ªát")
          .length,
        "B·ªã t·ª´ ch·ªëi": normalizedData.filter((p) => p.status === "B·ªã t·ª´ ch·ªëi")
          .length,
      };

      set({
        proposals: normalizedData,
        finalProposals: normalizedData,
        counts: newCounts,
        selectedProposalId: normalizedData[0]?.id || null,
        selectedProposal: normalizedData[0] || null,
        isLoading: false,
        error: null, // Clear error n·∫øu success
      });
      console.log("‚úÖ Loaded proposals:", normalizedData); // Debug
    } catch (e) {
      console.error("‚ùå L·ªói khi t·∫£i danh s√°ch ƒë·ªÅ t√†i:", e);
      set({
        error: e.message || "L·ªói k·∫øt n·ªëi",
        isLoading: false,
        proposals: [],
        finalProposals: [],
      });
    }
  },

  // ================== APPROVE PROPOSAL ==================
  approveProposal: async (id) => {
    const { selectedProposal } = get();
    if (selectedProposal?.status !== "Ch·ªù duy·ªát") {
      alert("Ch·ªâ c√≥ th·ªÉ duy·ªát ƒë·ªÅ t√†i ƒëang ch·ªù duy·ªát!");
      return;
    }
    set({ isLoading: true, error: null });
    try {
      const res = await fetch(`${PROPOSALS_URL}/${id}/status`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          ...authHeaders(), // ‚úÖ
        },
        body: JSON.stringify({ Status: "Approved" }),
      });

      const payload = await parseApiResponse(res);
      if (!res.ok) throw new Error(payload?.message || "Duy·ªát ƒë·ªÅ t√†i th·∫•t b·∫°i");

      await get().fetchProposals();
      set({
        selectedProposalId: null,
        selectedProposal: null,
        isLoading: false,
      });
    } catch (err) {
      console.error("L·ªói khi duy·ªát ƒë·ªÅ t√†i:", err);
      set({ error: err.message, isLoading: false });
      alert(`Duy·ªát th·∫•t b·∫°i: ${err.message}`);
    }
  },

  // ================== REJECT PROPOSAL ==================
  rejectProposal: async (id) => {
    const { selectedProposal } = get();
    if (selectedProposal?.status !== "Ch·ªù duy·ªát") {
      alert("Ch·ªâ c√≥ th·ªÉ t·ª´ ch·ªëi ƒë·ªÅ t√†i ƒëang ch·ªù duy·ªát!");
      return;
    }
    set({ isLoading: true, error: null });
    try {
      const res = await fetch(`${PROPOSALS_URL}/${id}/status`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          ...authHeaders(), // ‚úÖ
        },
        body: JSON.stringify({
          Status: "Rejected",
          RejectionReason: "Kh√¥ng ph√π h·ª£p",
        }),
      });

      const payload = await parseApiResponse(res);
      if (!res.ok)
        throw new Error(payload?.message || "T·ª´ ch·ªëi ƒë·ªÅ t√†i th·∫•t b·∫°i");

      await get().fetchProposals();
      set({
        selectedProposalId: null,
        selectedProposal: null,
        isLoading: false,
      });
    } catch (err) {
      console.error("L·ªói khi t·ª´ ch·ªëi ƒë·ªÅ t√†i:", err);
      set({ error: err.message, isLoading: false });
      alert(`T·ª´ ch·ªëi th·∫•t b·∫°i: ${err.message}`);
    }
  },

  // ================== DELETE PROPOSAL ==================
  deleteProposal: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const res = await fetch(`${PROPOSALS_URL}/${id}`, {
        method: "DELETE",
        headers: {
          ...authHeaders(), // ‚úÖ
        },
      });

      const payload = await parseApiResponse(res);
      if (!res.ok) throw new Error(payload?.message || "X√≥a ƒë·ªÅ t√†i th·∫•t b·∫°i");

      await get().fetchProposals();
      set({
        selectedProposalId: null,
        selectedProposal: null,
        isLoading: false,
      });
    } catch (err) {
      console.error("L·ªói khi x√≥a ƒë·ªÅ t√†i:", err);
      set({ error: err.message, isLoading: false });
      alert(`X√≥a th·∫•t b·∫°i: ${err.message}`);
    }
  },

  // ================== EDIT PROPOSAL ==================
  updateProposal: async (id, formData) => {
    try {
      const res = await fetch(`${PROPOSALS_URL}/${id}/update`, {
        method: "POST",
        headers: {
          ...authHeaders(), // ‚úÖ KH√îNG set Content-Type khi g·ª≠i FormData
        },
        body: formData,
      });
      const payload = await parseApiResponse(res);
      if (!res.ok)
        throw new Error(payload?.message || "C·∫≠p nh·∫≠t ƒë·ªÅ t√†i th·∫•t b·∫°i");

      await get().fetchProposals();
      set({ isModalOpen: false, mode: "add" });
      return true;
    } catch (err) {
      console.error("L·ªói khi c·∫≠p nh·∫≠t ƒë·ªÅ t√†i:", err);
      alert(`C·∫≠p nh·∫≠t th·∫•t b·∫°i: ${err.message}`);
      return false;
    }
  },

  // ===== Filter theo tab =====
  setFilterStatus: (status) => {
    let filtered = get().proposals || [];
    if (status !== "T·∫•t c·∫£") {
      filtered = filtered.filter((p) => p.status === status);
    }
    set({ finalProposals: filtered });
  },
}));
